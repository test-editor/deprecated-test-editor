/*******************************************************************************
 * Copyright (c) 2012 - 2015 Signal Iduna Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 * Signal Iduna Corporation - initial API and implementation
 * akquinet AG
 *******************************************************************************/
package org.testeditor.ui.handlers;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import org.eclipse.e4.core.contexts.ContextInjectionFactory;
import org.eclipse.e4.core.contexts.EclipseContextFactory;
import org.eclipse.e4.core.contexts.IEclipseContext;
import org.eclipse.e4.ui.model.application.MApplication;
import org.eclipse.e4.ui.model.application.ui.basic.MPart;
import org.eclipse.e4.ui.workbench.modeling.EPartService;
import org.junit.Before;
import org.junit.Test;
import org.testeditor.core.model.teststructure.TestCase;
import org.testeditor.core.model.teststructure.TestProject;
import org.testeditor.core.model.teststructure.TestProjectConfig;
import org.testeditor.core.model.teststructure.TestStructure;
import org.testeditor.core.model.teststructure.TestSuite;
import org.testeditor.ui.ITestStructureEditor;
import org.testeditor.ui.adapter.MPartAdapter;
import org.testeditor.ui.adapter.PartServiceAdapter;
import org.testeditor.ui.constants.TestEditorConstants;
import org.testeditor.ui.parts.projecteditor.TestProjectEditor;
import org.testeditor.ui.parts.testsuite.TestSuiteEditor;
import org.testeditor.ui.utilities.TestEditorTranslationService;

/**
 * 
 * IntegrationTests for the OpenTestStructureHandler.
 * 
 */
public class OpenTestStructureHandlerTest {

	private boolean activatedPart;
	private boolean createdPart;
	private IEclipseContext context;

	/**
	 * Create the EclipseContext for the Test and set a
	 * TestEditorTranslationsService.
	 */
	@Before
	public void createContext() {
		context = EclipseContextFactory.create();
		context.set(TestEditorTranslationService.class, null);
	}

	/**
	 * Test that Open works on single selection of <code>TestCase</code>.
	 * 
	 * @throws Exception
	 *             for Test
	 */
	@Test
	public void testCanExecuteOnSingleSelectionTestCase() throws Exception {
		OpenTestStructureHandler handler = new OpenTestStructureHandler();
		List<TestStructure> list = new ArrayList<TestStructure>();
		TestCase tc = new TestCase();
		new TestSuite().addChild(tc);
		list.add(tc);
		context.set(TestEditorConstants.TEST_EXPLORER_VIEW, new TestExplorerMock(list));
		assertTrue(handler.canExecute(context));
	}

	/**
	 * Test that Open works on single selection of <code>TestSuite</code>.
	 * 
	 * @throws Exception
	 *             for Test
	 */
	@Test
	public void testCanNotExecuteOnSingleSelectionTestSuite() throws Exception {
		OpenTestStructureHandler handler = new OpenTestStructureHandler();
		List<TestStructure> list = new ArrayList<TestStructure>();
		TestSuite suite = new TestSuite();
		suite.addChild(suite);
		list.add(suite);
		context.set(TestEditorConstants.TEST_EXPLORER_VIEW, new TestExplorerMock(list));
		assertTrue(handler.canExecute(context));
	}

	/**
	 * Execution on more than one Selection.
	 * 
	 * @throws Exception
	 *             for Test
	 */
	@Test
	public void testCanExecuteOnMultipleSelection() throws Exception {
		OpenTestStructureHandler handler = new OpenTestStructureHandler();
		List<TestStructure> list = new ArrayList<TestStructure>();
		TestSuite suite = new TestSuite();
		suite.addChild(suite);
		list.add(suite);
		TestCase tc = new TestCase();
		new TestSuite().addChild(tc);
		list.add(tc);
		context.set(TestEditorConstants.TEST_EXPLORER_VIEW, new TestExplorerMock(list));
		assertTrue(handler.canExecute(context));
	}

	/**
	 * Test that there is no execute on the Root Element.
	 * 
	 * @throws Exception
	 *             for Test
	 */
	@Test
	public void testCanNotExecuteOnRootSelection() throws Exception {
		OpenTestStructureHandler handler = new OpenTestStructureHandler();
		List<TestStructure> list = new ArrayList<TestStructure>();
		TestSuite suite = new TestSuite();
		list.add(suite);
		context.set(TestEditorConstants.TEST_EXPLORER_VIEW, new TestExplorerMock(list));
		assertFalse(handler.canExecute(context));
	}

	/**
	 * Test that there is no execute on the Root Element.
	 * 
	 * @throws Exception
	 *             for Test
	 */
	@Test
	public void testCanExecuteOnTestProject() throws Exception {
		OpenTestStructureHandler handler = new OpenTestStructureHandler();
		List<TestStructure> list = new ArrayList<TestStructure>();
		TestProject project = new TestProject();
		project.setTestProjectConfig(new TestProjectConfig());
		list.add(project);
		context.set(TestEditorConstants.TEST_EXPLORER_VIEW, new TestExplorerMock(list));
		assertTrue(handler.canExecute(context));
	}

	/**
	 * Test that there is no execute on the Root Element.
	 * 
	 * @throws Exception
	 *             for Test
	 */
	@Test
	public void testCanExecuteOnTestProjectWithOutConfig() throws Exception {
		OpenTestStructureHandler handler = new OpenTestStructureHandler();
		List<TestStructure> list = new ArrayList<TestStructure>();
		TestProject project = new TestProject();
		list.add(project);
		context.set(TestEditorConstants.TEST_EXPLORER_VIEW, new TestExplorerMock(list));
		assertFalse(handler.canExecute(context));
	}

	/**
	 * Tests the TestExplorer lookup from the context and evaluate the selection
	 * of the Tree for opening.
	 */
	@Test
	public void testEcecuteWithContext() {
		List<TestStructure> list = new ArrayList<TestStructure>();
		TestProject project = new TestProject();
		list.add(project);
		context.set(TestEditorConstants.TEST_EXPLORER_VIEW, new TestExplorerMock(list));
		context.set(MApplication.class, null);
		final TestCase testCase = new TestCase();
		testCase.setName("hello");
		context.set(EPartService.class, getParServiceMock("MyId", new TestProjectEditor(new MPartAdapter()) {

			@Override
			public TestStructure getTestStructure() {
				return testCase;
			}

			@Override
			public void setTestProject(TestProject testProject) {
			}

		}));
		OpenTestStructureHandler handler = ContextInjectionFactory.make(OpenTestStructureHandler.class, context);
		handler.execute(context);
		assertTrue(activatedPart);
	}

	/**
	 * Test the search of an open Editor for an not the same given Object.
	 */
	@Test
	public void testSearchForOpenEditorFoundsNullWithoutSameObject() {
		final TestCase testCase = new TestCase();
		testCase.setName("hello2");
		context.set(MApplication.class, null);
		context.set(EPartService.class, getParServiceMock("MyId", new TestSuiteEditor(new MPartAdapter()) {

			@Override
			public TestStructure getTestStructure() {
				return testCase;
			}

			@Override
			public void setTestSuite(TestSuite testSuite) {
			}
		}));
		OpenTestStructureHandler handler = ContextInjectionFactory.make(OpenTestStructureHandler.class, context);
		TestCase testStructure = new TestCase();
		testStructure.setName("hello");
		MPart foundPart = handler.searchForOpenTestStructureEditor("MyId", testStructure,
				context.get(EPartService.class));
		assertNull("Expecting no Editor found.", foundPart);
	}

	/**
	 * Test the search of an open Editor for an given Object.
	 */
	@Test
	public void testSearchForOpenEditorFoundsWithSameObject() {
		final TestCase testCase = new TestCase();
		testCase.setName("hello");
		context.set(MApplication.class, null);
		context.set(EPartService.class, getParServiceMock("MyId", new TestSuiteEditor(new MPartAdapter()) {

			@Override
			public TestStructure getTestStructure() {
				return testCase;
			}

			@Override
			public void setTestSuite(TestSuite testSuite) {
			}
		}));
		OpenTestStructureHandler handler = ContextInjectionFactory.make(OpenTestStructureHandler.class, context);
		TestCase testStructure = new TestCase();
		testStructure.setName("hello");
		MPart foundPart = handler.searchForOpenTestStructureEditor("MyId", testStructure,
				context.get(EPartService.class));
		assertNotNull("Expecting no Editor found.", foundPart);
	}

	/**
	 * Opening or creating a TestSuiteEditor.
	 */
	@Test
	public void testExecuteOnTestSuite() {
		final TestSuite testCase = new TestSuite();
		testCase.setName("hello");
		context.set(MApplication.class, null);
		context.set(EPartService.class, getParServiceMock(TestSuiteEditor.ID, new TestSuiteEditor(new MPartAdapter()) {

			@Override
			public TestStructure getTestStructure() {
				return testCase;
			}

			@Override
			public void setTestSuite(TestSuite testSuite) {
			}
		}));
		OpenTestStructureHandler handler = ContextInjectionFactory.make(OpenTestStructureHandler.class, context);
		TestSuite testSuite = new TestSuite();
		testSuite.setName("hello");
		handler.execute(testSuite, context);
		assertTrue("Activate Part is called", activatedPart);
		assertFalse("Created Part is called", createdPart);
		testSuite = new TestSuite();
		testSuite.setName("hello2");
		handler.execute(testSuite, context);
		assertTrue("Activate Part is called", activatedPart);
		assertTrue("Created Part is called", createdPart);
	}

	/**
	 * Opening or creating a TestProjectEditor.
	 */
	@Test
	public void testExecuteonTestProject() {
		final TestProject testProject = new TestProject();
		testProject.setName("hello");
		context.set(MApplication.class, null);
		context.set(EPartService.class,
				getParServiceMock(TestProjectEditor.ID, new TestProjectEditor(new MPartAdapter()) {

					@Override
					public TestStructure getTestStructure() {
						return testProject;
					}

					@Override
					public void setTestProject(TestProject testProject) {
					}

				}));
		OpenTestStructureHandler handler = ContextInjectionFactory.make(OpenTestStructureHandler.class, context);
		TestProject testPrj = new TestProject();
		testPrj.setName("hello");
		handler.execute(testPrj, context);
		assertTrue("Activate Part is called", activatedPart);
		assertFalse("Created Part is called", createdPart);
		testPrj = new TestProject();
		testPrj.setName("hello2");
		handler.execute(testPrj, context);
		assertTrue("Activate Part is called", activatedPart);
		assertTrue("Created Part is called", createdPart);
	}

	/**
	 * 
	 * @param id
	 *            of the MPart.
	 * @param editor
	 *            to be used in the mock.
	 * @return PartServiceMock for tests.
	 */
	private EPartService getParServiceMock(final String id, final ITestStructureEditor editor) {
		return new PartServiceAdapter() {
			@Override
			public Collection<MPart> getParts() {
				Collection<MPart> list = new ArrayList<MPart>();
				list.add(new MPartAdapter() {
					@Override
					public String getElementId() {
						return "NotMyId";
					};
				});
				list.add(new MPartAdapter() {
					@Override
					public String getElementId() {
						return id;
					};

					@Override
					public Object getObject() {
						return editor;
					}
				});
				return list;
			}

			@Override
			public MPart showPart(MPart part, PartState partState) {
				activatedPart = true;
				return part;
			}

			@Override
			public MPart createPart(String id) {
				createdPart = true;
				return new MPartAdapter() {
					@Override
					public Object getObject() {
						return editor;
					}
				};
			}

		};
	}

	/**
	 * Init the State of the Test variables.
	 */
	@Before
	public void setUp() {
		activatedPart = false;
		createdPart = false;
	}

}
